{
  "version": 3,
  "sources": ["../../cubing/src/cubing/kpuzzle/combine.ts", "../../cubing/src/cubing/kpuzzle/construct.ts", "../../cubing/src/cubing/kpuzzle/KPattern.ts", "../../cubing/src/cubing/kpuzzle/KTransformation.ts", "../../cubing/src/cubing/kpuzzle/calculate.ts", "../../cubing/src/cubing/kpuzzle/KPuzzle.ts"],
  "sourcesContent": ["import { isOrbitTransformationDataIdentityUncached } from \"./calculate\";\nimport type {\n  KPuzzleDefinition,\n  KPatternData,\n  KPatternOrbitData,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\n\nexport function combineTransformationData(\n  definition: KPuzzleDefinition,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): KTransformationData {\n  const newTransformationData = {} as KTransformationData;\n  for (const orbitDefinition of definition.orbits) {\n    const orbit1 = transformationData1[orbitDefinition.orbitName];\n    const orbit2 = transformationData2[orbitDefinition.orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit2,\n      )\n    ) {\n      // common case for big cubes\n      newTransformationData[orbitDefinition.orbitName] = orbit1;\n    } else if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit1,\n      )\n    ) {\n      newTransformationData[orbitDefinition.orbitName] = orbit2;\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitDefinition.orbitName] = {\n          permutation: newPerm,\n          orientationDelta: orbit1.orientationDelta,\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] =\n            (orbit1.orientationDelta[orbit2.permutation[idx]] +\n              orbit2.orientationDelta[idx]) %\n            orbitDefinition.numOrientations;\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitDefinition.orbitName] = {\n          permutation: newPerm,\n          orientationDelta: newOri,\n        };\n      }\n    }\n  }\n  return newTransformationData;\n}\n\nexport function applyTransformationDataToKPatternData(\n  definition: KPuzzleDefinition,\n  patternData: KPatternData,\n  transformationData: KTransformationData,\n): KPatternData {\n  const newPatternData = {} as KPatternData;\n  for (const orbitDefinition of definition.orbits) {\n    const patternOrbit = patternData[orbitDefinition.orbitName];\n    const transformationOrbit = transformationData[orbitDefinition.orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        transformationOrbit,\n      )\n    ) {\n      // common case for big cubes\n      newPatternData[orbitDefinition.orbitName] = patternOrbit;\n    } else {\n      const newPieces = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPieces[idx] =\n            patternOrbit.pieces[transformationOrbit.permutation[idx]];\n        }\n        const newOrbitData: KPatternOrbitData = {\n          pieces: newPieces,\n          orientation: patternOrbit.orientation, // copy all 0\n        };\n        newPatternData[orbitDefinition.orbitName] = newOrbitData;\n      } else {\n        const newOrientation = new Array(orbitDefinition.numPieces);\n        const newOrientationMod: number[] | undefined =\n          patternOrbit.orientationMod\n            ? new Array(orbitDefinition.numPieces)\n            : undefined;\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          const transformationIdx = transformationOrbit.permutation[idx];\n          let mod = orbitDefinition.numOrientations;\n          if (patternOrbit.orientationMod) {\n            const orientationMod =\n              patternOrbit.orientationMod[transformationIdx];\n            newOrientationMod![idx] = orientationMod;\n            mod = orientationMod || orbitDefinition.numOrientations;\n          }\n          newOrientation[idx] =\n            (patternOrbit.orientation[transformationIdx] +\n              transformationOrbit.orientationDelta[idx]) %\n            mod; // We don't have to use `modIntoRange` (assuming input is well-formed), because we're adding.\n          newPieces[idx] = patternOrbit.pieces[transformationIdx];\n        }\n        const newOrbitData: KPatternOrbitData = {\n          pieces: newPieces,\n          orientation: newOrientation,\n        };\n        if (newOrientationMod) {\n          newOrbitData.orientationMod = newOrientationMod;\n        }\n        newPatternData[orbitDefinition.orbitName] = newOrbitData;\n      }\n    }\n  }\n  return newPatternData;\n}\n", "import type { Move } from \"../alg\";\nimport { repeatTransformationUncached } from \"./calculate\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KPuzzleDefinition,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\n\nconst FREEZE: boolean = false;\n\nconst identityOrbitCache = new Map<number, KTransformationOrbitData>();\nfunction constructIdentityOrbitTransformation(\n  numPieces: number,\n): KTransformationOrbitData {\n  const cached = identityOrbitCache.get(numPieces);\n  if (cached) {\n    return cached;\n  }\n\n  const newPermutation = new Array(numPieces);\n  const newOrientation = new Array(numPieces);\n  for (let i = 0; i < numPieces; i++) {\n    newPermutation[i] = i;\n    newOrientation[i] = 0;\n  }\n  const orbitTransformation = {\n    permutation: newPermutation,\n    orientationDelta: newOrientation,\n  };\n  if (FREEZE) {\n    Object.freeze(newPermutation); // TODO\n    Object.freeze(newOrientation); // TODO\n    Object.freeze(orbitTransformation); // TODO\n  }\n  identityOrbitCache.set(numPieces, orbitTransformation);\n  return orbitTransformation;\n}\n\nexport function constructIdentityTransformationDataUncached(\n  definition: KPuzzleDefinition,\n): KTransformationData {\n  const transformation = {} as KTransformationData;\n  for (const orbitDefinition of definition.orbits) {\n    transformation[orbitDefinition.orbitName] =\n      constructIdentityOrbitTransformation(orbitDefinition.numPieces);\n  }\n  if (FREEZE) {\n    Object.freeze(transformation); // TODO\n  }\n  return transformation;\n}\n\nexport function moveToTransformationUncached(\n  kpuzzle: KPuzzle,\n  move: Move,\n): KTransformationData {\n  function getTransformationData(\n    key: {\n      toString: () => string;\n    },\n    multiplyAmount: number,\n  ): KTransformationData | undefined {\n    const s = key.toString();\n    const movesDef = kpuzzle.definition.moves[s];\n    if (movesDef) {\n      return repeatTransformationUncached(kpuzzle, movesDef, multiplyAmount);\n    }\n    const derivedDef = kpuzzle.definition.derivedMoves?.[s];\n    if (derivedDef) {\n      return repeatTransformationUncached(\n        kpuzzle,\n        kpuzzle.algToTransformation(derivedDef).transformationData,\n        multiplyAmount,\n      );\n    }\n    return undefined;\n  }\n\n  // TODO: Use Euclid's algorithm to pre-calculate the GCD of moves for each\n  // quantum, along with its transformation. This will make lookup `O(1)` for multiples of e.g. `y2`.\n\n  const data =\n    getTransformationData(move.quantum, move.amount) ??\n    // Handle e.g. `y2` if `y2` is defined.\n    // Note: this doesn't handle multiples.\n    getTransformationData(move, 1) ??\n    // Handle e.g. `y2'` if `y2` is defined.\n    // Note: this doesn't handle multiples.\n    getTransformationData(move.invert, -1);\n\n  if (data) {\n    return data;\n  }\n  throw new Error(`Invalid move for KPuzzle (${kpuzzle.name()}): ${move}`);\n}\n", "import type { KPuzzle } from \"./KPuzzle\";\nimport type { Alg, Move } from \"../alg\";\nimport { applyTransformationDataToKPatternData } from \"./combine\";\nimport type { KTransformationSource } from \"./KPuzzle\";\nimport type {\n  KPatternData,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\nimport { isPatternDataIdentical } from \"./calculate\";\n\nexport class KPattern {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly patternData: KPatternData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      patternData: this.patternData,\n    };\n  }\n\n  static fromTransformation(transformation: KTransformation): KPattern {\n    const newPatternData = applyTransformationDataToKPatternData(\n      transformation.kpuzzle.definition,\n      transformation.kpuzzle.definition.defaultPattern,\n      transformation.transformationData,\n    );\n    return new KPattern(transformation.kpuzzle, newPatternData);\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KPattern {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(transformation: KTransformation): KPattern {\n    if (transformation.isIdentityTransformation()) {\n      return new KPattern(this.kpuzzle, this.patternData);\n    }\n    const newPatternData = applyTransformationDataToKPatternData(\n      this.kpuzzle.definition,\n      this.patternData,\n      transformation.transformationData,\n    );\n    return new KPattern(this.kpuzzle, newPatternData);\n  }\n\n  applyMove(move: Move | string): KPattern {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KPattern {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  isIdentical(other: KPattern): boolean {\n    return isPatternDataIdentical(\n      this.kpuzzle,\n      this.patternData,\n      other.patternData,\n    );\n  }\n\n  /** @deprecated */\n  experimentalToTransformation(): KTransformation | null {\n    if (!this.kpuzzle.canConvertDefaultPatternToUniqueTransformation()) {\n      return null;\n    }\n    const transformationData: KTransformationData = {};\n    for (const [orbitName, patternOrbitData] of Object.entries(\n      this.patternData,\n    )) {\n      const transformationOrbit: KTransformationOrbitData = {\n        permutation: patternOrbitData.pieces,\n        orientationDelta: patternOrbitData.orientation,\n      };\n      transformationData[orbitName] = transformationOrbit;\n    }\n    return new KTransformation(this.kpuzzle, transformationData);\n  }\n\n  experimentalIsSolved(options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean;\n  }): boolean {\n    if (!this.kpuzzle.definition.experimentalIsPatternSolved) {\n      throw new Error(\n        \"`KPattern.experimentalIsPatternSolved()` is not supported for this puzzle at the moment.\",\n      );\n    }\n    return this.kpuzzle.definition.experimentalIsPatternSolved(this, options);\n  }\n}\n", "import type { Alg, Move } from \"../alg\";\nimport {\n  invertTransformation,\n  isTransformationDataIdentical,\n  repeatTransformationUncached,\n  transformationRepetitionOrder,\n} from \"./calculate\";\nimport { combineTransformationData } from \"./combine\";\nimport { constructIdentityTransformationDataUncached } from \"./construct\";\nimport type { KPuzzle, KTransformationSource } from \"./KPuzzle\";\nimport type { KTransformationData } from \"./KPuzzleDefinition\";\nimport { KPattern } from \"./KPattern\";\n\nexport class KTransformation {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly transformationData: KTransformationData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      transformationData: this.transformationData,\n    };\n  }\n\n  invert(): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      invertTransformation(this.kpuzzle, this.transformationData),\n    );\n  }\n\n  // For optimizations, we want to make it cheap to rely on optimizations when a\n  // transformation is an identity. Here, we try to make it cheaper by:\n  // - only calculating when needed, and\n  // - caching the result.\n  #cachedIsIdentity: boolean | undefined; // TODO: is `null` worse here?\n  isIdentityTransformation(): boolean {\n    return (this.#cachedIsIdentity ??= this.isIdentical(\n      this.kpuzzle.identityTransformation(),\n    ));\n  }\n\n  /** @deprecated */\n  static experimentalConstructIdentity(kpuzzle: KPuzzle) {\n    const transformation = new KTransformation(\n      kpuzzle,\n      constructIdentityTransformationDataUncached(kpuzzle.definition),\n    );\n    transformation.#cachedIsIdentity = true;\n    return transformation;\n  }\n\n  isIdentical(t2: KTransformation): boolean {\n    return isTransformationDataIdentical(\n      this.kpuzzle,\n      this.transformationData,\n      t2.transformationData,\n    );\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KTransformation {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(t2: KTransformation): KTransformation {\n    if (this.kpuzzle !== t2.kpuzzle) {\n      throw new Error(\n        `Tried to apply a transformation for a KPuzzle (${t2.kpuzzle.name()}) to a different KPuzzle (${this.kpuzzle.name()}).`,\n      );\n    }\n\n    if (this.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, t2.transformationData);\n    }\n    if (t2.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, this.transformationData);\n    }\n\n    return new KTransformation(\n      this.kpuzzle,\n      combineTransformationData(\n        this.kpuzzle.definition,\n        this.transformationData,\n        t2.transformationData,\n      ),\n    );\n  }\n\n  applyMove(move: Move | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  // Convenience. Useful for chaining.\n  toKPattern(): KPattern {\n    return KPattern.fromTransformation(this);\n  }\n\n  // TODO: support calculating this for a given start state. (For `R U R' U` on 3x3x3, should this default to 5 or 10?)\n  repetitionOrder(): number {\n    return transformationRepetitionOrder(this.kpuzzle.definition, this);\n  }\n\n  selfMultiply(amount: number): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      repeatTransformationUncached(\n        this.kpuzzle,\n        this.transformationData,\n        amount,\n      ),\n    );\n  }\n}\n", "import {\n  Alg,\n  Commutator,\n  Conjugate,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n  TraversalDownUp,\n} from \"../alg\";\nimport { functionFromTraversal } from \"../alg\";\nimport { combineTransformationData } from \"./combine\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KPuzzleOrbitDefinition,\n  KTransformationOrbitData,\n  KTransformationData,\n  KPuzzleDefinition,\n  KPatternData,\n  KPatternOrbitData,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport function isOrbitTransformationDataIdentityUncached(\n  numOrientations: number,\n  orbitTransformationData: KTransformationOrbitData,\n): boolean {\n  // TODO\n  // if (o === lasto) {\n  //   return true;\n  // }\n  if (!orbitTransformationData.permutation) {\n    console.log(orbitTransformationData);\n  }\n  const { permutation } = orbitTransformationData;\n  const numPieces = permutation.length;\n  for (let idx = 0; idx < numPieces; idx++) {\n    if (permutation[idx] !== idx) {\n      return false;\n    }\n  }\n  if (numOrientations > 1) {\n    const { orientationDelta: orientation } = orbitTransformationData;\n    for (let idx = 0; idx < numPieces; idx++) {\n      if (orientation[idx] !== 0) {\n        return false;\n      }\n    }\n  }\n  // lasto = o; // TODO\n  return true;\n}\n\nexport function isOrbitTransformationDataIdentical(\n  orbitDefinition: KPuzzleOrbitDefinition,\n  orbitTransformationData1: KTransformationOrbitData,\n  orbitTransformationData2: KTransformationOrbitData,\n  options: {\n    ignorePieceOrientations?: boolean;\n    ignorePiecePermutation?: boolean;\n  } = {},\n): boolean {\n  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n    if (\n      !options?.ignorePieceOrientations &&\n      orbitTransformationData1.orientationDelta[idx] !==\n        orbitTransformationData2.orientationDelta[idx]\n    ) {\n      return false;\n    }\n    if (\n      !options?.ignorePiecePermutation &&\n      orbitTransformationData1.permutation[idx] !==\n        orbitTransformationData2.permutation[idx]\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isTransformationDataIdentical(\n  kpuzzle: KPuzzle,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): boolean {\n  for (const orbitDefinition of kpuzzle.definition.orbits) {\n    if (\n      !isOrbitTransformationDataIdentical(\n        orbitDefinition,\n        transformationData1[orbitDefinition.orbitName],\n        transformationData2[orbitDefinition.orbitName],\n      )\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction isOrbitPatternDataIdentical(\n  orbitDefinition: KPuzzleOrbitDefinition,\n  orbitPatternData1: KPatternOrbitData,\n  orbitPatternData2: KPatternOrbitData,\n  options: {\n    ignorePieceOrientations?: boolean;\n    ignorePieceIndices?: boolean;\n  } = {},\n): boolean {\n  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n    if (\n      !options?.ignorePieceOrientations &&\n      (orbitPatternData1.orientation[idx] !==\n        orbitPatternData2.orientation[idx] ||\n        (orbitPatternData1.orientationMod?.[idx] ?? 0) !==\n          (orbitPatternData2.orientationMod?.[idx] ?? 0))\n    ) {\n      return false;\n    }\n    if (\n      !options?.ignorePieceIndices &&\n      orbitPatternData1.pieces[idx] !== orbitPatternData2.pieces[idx]\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isPatternDataIdentical(\n  kpuzzle: KPuzzle,\n  patternData1: KPatternData,\n  patternData2: KPatternData,\n): boolean {\n  for (const orbitDefinition of kpuzzle.definition.orbits) {\n    if (\n      !isOrbitPatternDataIdentical(\n        orbitDefinition,\n        patternData1[orbitDefinition.orbitName],\n        patternData2[orbitDefinition.orbitName],\n      )\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function invertTransformation(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n): KTransformationData {\n  const newTransformationData: KTransformationData = {};\n  for (const orbitDefinition of kpuzzle.definition.orbits) {\n    const orbitTransformationData =\n      transformationData[orbitDefinition.orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbitTransformationData,\n      )\n    ) {\n      newTransformationData[orbitDefinition.orbitName] =\n        orbitTransformationData;\n    } else if (orbitDefinition.numOrientations === 1) {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        newPerm[orbitTransformationData.permutation[idx]] = idx;\n      }\n      newTransformationData[orbitDefinition.orbitName] = {\n        permutation: newPerm,\n        orientationDelta: orbitTransformationData.orientationDelta,\n      };\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      const newOri = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        const fromIdx = orbitTransformationData.permutation[idx];\n        newPerm[fromIdx] = idx;\n        newOri[fromIdx] =\n          (orbitDefinition.numOrientations -\n            orbitTransformationData.orientationDelta[idx] +\n            orbitDefinition.numOrientations) %\n          orbitDefinition.numOrientations;\n      }\n      newTransformationData[orbitDefinition.orbitName] = {\n        permutation: newPerm,\n        orientationDelta: newOri,\n      };\n    }\n  }\n  return newTransformationData;\n}\n\nexport function repeatTransformationUncached(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n  amount: number,\n): KTransformationData {\n  // This is used for move construction, so we optimize for the quantum move case.\n  if (amount === 1) {\n    return transformationData;\n  }\n  if (amount < 0) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      invertTransformation(kpuzzle, transformationData),\n      -amount,\n    );\n  }\n  if (amount === 0) {\n    // TODO\n    const { transformationData } = kpuzzle.identityTransformation();\n    return transformationData;\n  }\n  let halfish = transformationData;\n  if (amount !== 2) {\n    halfish = repeatTransformationUncached(\n      kpuzzle,\n      transformationData,\n      Math.floor(amount / 2),\n    );\n  }\n  const twiceHalfish = combineTransformationData(\n    kpuzzle.definition,\n    halfish,\n    halfish,\n  );\n  if (amount % 2 === 0) {\n    return twiceHalfish;\n  } else {\n    return combineTransformationData(\n      kpuzzle.definition,\n      transformationData,\n      twiceHalfish,\n    );\n  }\n}\n\nclass AlgToTransformationTraversal extends TraversalDownUp<\n  KPuzzle,\n  KTransformation\n> {\n  traverseAlg(alg: Alg, kpuzzle: KPuzzle): KTransformation {\n    let transformation: KTransformation | null = null;\n    for (const algNode of alg.childAlgNodes()) {\n      if (transformation) {\n        transformation = transformation.applyTransformation(\n          this.traverseAlgNode(algNode, kpuzzle),\n        );\n      } else {\n        transformation = this.traverseAlgNode(algNode, kpuzzle);\n      }\n    }\n    return transformation ?? kpuzzle.identityTransformation();\n  }\n  traverseGrouping(grouping: Grouping, kpuzzle: KPuzzle): KTransformation {\n    const algTransformation = this.traverseAlg(grouping.alg, kpuzzle);\n    return new KTransformation(\n      kpuzzle,\n      repeatTransformationUncached(\n        kpuzzle,\n        algTransformation.transformationData,\n        grouping.amount,\n      ),\n    );\n  }\n  traverseMove(move: Move, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.moveToTransformation(move);\n  }\n  traverseCommutator(\n    commutator: Commutator,\n    kpuzzle: KPuzzle,\n  ): KTransformation {\n    const aTransformation = this.traverseAlg(commutator.A, kpuzzle);\n    const bTransformation = this.traverseAlg(commutator.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert())\n      .applyTransformation(bTransformation.invert());\n  }\n  traverseConjugate(conjugate: Conjugate, kpuzzle: KPuzzle): KTransformation {\n    const aTransformation = this.traverseAlg(conjugate.A, kpuzzle);\n    const bTransformation = this.traverseAlg(conjugate.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert());\n  }\n  traversePause(_: Pause, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseNewline(_: Newline, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseLineComment(_: LineComment, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n}\n\nexport const algToTransformation = functionFromTraversal(\n  AlgToTransformationTraversal,\n);\n\nexport function canConvertDefaultPatternToUniqueTransformationUncached(\n  definition: KPuzzleDefinition,\n): boolean {\n  for (const orbitDefinition of definition.orbits) {\n    const pieces = new Array(orbitDefinition.numPieces).fill(false);\n    for (const piece of this.definition.defaultPattern[\n      orbitDefinition.orbitName\n    ].pieces) {\n      pieces[piece] = true;\n    }\n    for (const piece of pieces) {\n      if (!piece) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (b) {\n    return gcd(b, a % b);\n  }\n  return a;\n}\n\n/* calculate the order of a particular transformation. */\nexport function transformationRepetitionOrder(\n  definition: KPuzzleDefinition,\n  transformation: KTransformation,\n): number {\n  let order: number = 1;\n  for (const orbitDefinition of definition.orbits) {\n    const transformationOrbit =\n      transformation.transformationData[orbitDefinition.orbitName];\n    const orbitPieces = new Array(orbitDefinition.numPieces);\n    for (let startIdx = 0; startIdx < orbitDefinition.numPieces; startIdx++) {\n      if (!orbitPieces[startIdx]) {\n        let currentIdx = startIdx;\n        let orientationSum = 0;\n        let cycleLength = 0;\n        for (;;) {\n          orbitPieces[currentIdx] = true;\n          orientationSum =\n            orientationSum + transformationOrbit.orientationDelta[currentIdx];\n          cycleLength = cycleLength + 1;\n          currentIdx = transformationOrbit.permutation[currentIdx];\n          if (currentIdx === startIdx) {\n            break;\n          }\n        }\n        if (orientationSum !== 0) {\n          cycleLength =\n            (cycleLength * orbitDefinition.numOrientations) /\n            gcd(orbitDefinition.numOrientations, Math.abs(orientationSum));\n        }\n        order = (order * cycleLength) / gcd(order, cycleLength);\n      }\n    }\n  }\n  return order;\n}\n", "import { Alg, Move } from \"../alg\";\nimport type { PGNotation } from \"../puzzle-geometry/PuzzleGeometry\";\nimport { algToTransformation } from \"./calculate\";\nimport { moveToTransformationUncached } from \"./construct\";\nimport type {\n  KPuzzleDefinition,\n  KPuzzleOrbitDefinition,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\nimport { KPattern } from \"./KPattern\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport type KTransformationSource = Alg | Move | string | KTransformation;\n\nexport class KPuzzle {\n  private experimentalPGNotation: PGNotation | undefined;\n  constructor(\n    public readonly definition: KPuzzleDefinition,\n    options?: {\n      experimentalPGNotation?: PGNotation;\n    },\n  ) {\n    this.experimentalPGNotation = options?.experimentalPGNotation;\n  }\n\n  #indexedOrbits: Record<string, KPuzzleOrbitDefinition> | undefined;\n  // Note: this function is needed much more rarely than you might think. Most\n  // operations related to orbits require iterating through all of them, for\n  // which the following is better:\n  //\n  //    for (const orbitDefinition of kpuzzle.definition.orbits) { // \u2026\n  //    }\n  lookupOrbitDefinition(orbitName: string): KPuzzleOrbitDefinition {\n    this.#indexedOrbits ||= (() => {\n      const indexedOrbits: Record<string, KPuzzleOrbitDefinition> = {};\n      for (const orbitDefinition of this.definition.orbits) {\n        indexedOrbits[orbitDefinition.orbitName] = orbitDefinition;\n      }\n      return indexedOrbits;\n    })();\n    return this.#indexedOrbits[orbitName];\n  }\n\n  name(): string {\n    return this.definition.name; // TODO\n  }\n\n  identityTransformation(): KTransformation {\n    return KTransformation.experimentalConstructIdentity(this);\n  }\n\n  #moveToTransformationDataCache = new Map<string, KTransformationData>();\n  moveToTransformation(move: Move | string): KTransformation {\n    if (typeof move === \"string\") {\n      move = new Move(move);\n    }\n    const cacheKey = move.toString();\n    const cachedTransformationData: KTransformationData | undefined =\n      this.#moveToTransformationDataCache.get(cacheKey);\n    if (cachedTransformationData) {\n      return new KTransformation(this, cachedTransformationData);\n    }\n\n    if (this.experimentalPGNotation) {\n      const transformationData = this.experimentalPGNotation.lookupMove(move);\n      if (!transformationData) {\n        throw new Error(`could not map to internal move: ${move}`);\n      }\n      this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n      return new KTransformation(this, transformationData);\n    }\n\n    const transformationData = moveToTransformationUncached(this, move);\n    this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n    return new KTransformation(this, transformationData);\n  }\n\n  algToTransformation(alg: Alg | string): KTransformation {\n    if (typeof alg === \"string\") {\n      alg = new Alg(alg);\n    }\n    return algToTransformation(alg, this);\n  }\n\n  /** @deprecated */\n  toTransformation(source: KTransformationSource): KTransformation {\n    if (typeof source === \"string\") {\n      return this.algToTransformation(source);\n    } else if ((source as Alg | null)?.is?.(Alg)) {\n      return this.algToTransformation(source as Alg);\n    } else if ((source as Move | null)?.is?.(Move)) {\n      return this.moveToTransformation(source as Move);\n    } else {\n      return source as KTransformation;\n    }\n  }\n\n  defaultPattern(): KPattern {\n    return new KPattern(this, this.definition.defaultPattern);\n  }\n\n  #cachedCanConvertDefaultPatternToUniqueTransformation: boolean | undefined;\n  // TODO: Handle incomplete default pattern data\n  canConvertDefaultPatternToUniqueTransformation(): boolean {\n    return (this.#cachedCanConvertDefaultPatternToUniqueTransformation ??=\n      ((): boolean => {\n        for (const orbitDefinition of this.definition.orbits) {\n          const pieces = new Array(orbitDefinition.numPieces).fill(false);\n          for (const piece of this.definition.defaultPattern[\n            orbitDefinition.orbitName\n          ].pieces) {\n            pieces[piece] = true;\n          }\n          for (const piece of pieces) {\n            if (!piece) {\n              return false;\n            }\n          }\n        }\n        return true;\n      })());\n  }\n}\n"],
  "mappings": "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",
  "names": ["_a", "transformationData"]
}
